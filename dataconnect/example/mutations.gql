# ===================================================================
# Mutation Examples for Grade Web App
# Ejemplos de mutaciones para el sistema de gestión de calificaciones
# Enfocado en CRUD de Asignaturas, Unidades y Temas con Soft Delete
# ===================================================================

# ===================================================================
# USUARIOS (Users)
# ===================================================================

# Crear un nuevo usuario
mutation CreateUser(
  $userId: UUID!
  $firebaseId: String!
  $name: String!
  $email: String!
  $role: String!
  $createdBy: UUID!
) @auth(level: USER) {
  user_insert(
    data: {
      userId: $userId
      firebaseId: $firebaseId
      name: $name
      email: $email
      role: $role
      createdBy: $createdBy
    }
  )
}

# Actualizar un usuario
mutation UpdateUser(
  $userId: UUID!
  $name: String
  $email: String
  $role: String
  $updatedBy: UUID!
  $updatedAt: Timestamp!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  user_update(
    key: { userId: $userId }
    data: {
      name: $name
      email: $email
      role: $role
      updatedBy: $updatedBy
      updatedAt: $updatedAt
    }
  )
}

# ===================================================================
# ASIGNATURAS (Subjects)
# ===================================================================

# Crear una nueva asignatura
mutation CreateSubject(
  $subjectId: UUID!
  $name: String!
  $code: String!
  $levelId: UUID!
  $description: String
  $createdBy: UUID!
) @auth(level: USER) {
  subject_insert(
    data: {
      subjectId: $subjectId
      name: $name
      code: $code
      description: $description
      levelId: $levelId
      createdBy: $createdBy
      active: true
    }
  )
}

# Actualizar una asignatura
mutation UpdateSubject(
  $subjectId: UUID!
  $name: String
  $code: String
  $description: String
  $updatedBy: UUID!
  $updatedAt: Timestamp!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  subject_update(
    key: { subjectId: $subjectId }
    data: {
      name: $name
      code: $code
      description: $description
      updatedBy: $updatedBy
      updatedAt: $updatedAt
    }
  )
}

# Desactivar una asignatura (soft delete)
mutation DeactivateSubject(
  $subjectId: UUID!
  $deletedAt: Timestamp!
  $deletedBy: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  subject_update(
    key: { subjectId: $subjectId }
    data: {
      active: false
      deletedAt: $deletedAt
      deletedBy: $deletedBy
    }
  )
}

# Reactivar una asignatura (undo soft delete)
mutation ReactivateSubject(
  $subjectId: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  subject_update(
    key: { subjectId: $subjectId }
    data: {
      active: true
      deletedAt: null
      deletedBy: null
    }
  )
}

# ===================================================================
# UNIDADES (Units)
# ===================================================================

# Crear una nueva unidad dentro de una asignatura
mutation CreateUnit(
  $unitId: UUID!
  $code: String!
  $name: String!
  $description: String
  $subjectId: UUID!
  $createdBy: UUID!
) @auth(level: USER) {
  unit_insert(
    data: {
      unitId: $unitId
      code: $code
      name: $name
      description: $description
      subjectId: $subjectId
      createdBy: $createdBy
      active: true
    }
  )
}

# Actualizar una unidad
mutation UpdateUnit(
  $unitId: UUID!
  $code: String!
  $name: String!
  $description: String
  $subjectId: UUID!
  $updatedBy: UUID!
  $updatedAt: Timestamp!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  unit_update(
    key: { unitId: $unitId }
    data: {
      code: $code
      name: $name
      description: $description
      updatedBy: $updatedBy
      updatedAt: $updatedAt
    }
  )
}

# Desactivar una unidad (soft delete)
# Nota: Verificar si hay temas asociados antes de desactivar
mutation DeactivateUnit(
  $unitId: UUID!
  $deletedAt: Timestamp!
  $deletedBy: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  unit_update(
    key: { unitId: $unitId }
    data: {
      active: false
      deletedAt: $deletedAt
      deletedBy: $deletedBy
    }
  )
}

# Reactivar una unidad (undo soft delete)
mutation ReactivateUnit(
  $unitId: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  unit_update(
    key: { unitId: $unitId }
    data: {
      active: true
      deletedAt: null
      deletedBy: null
    }
  )
}

# ===================================================================
# TEMAS (Topics)
# ===================================================================

# Crear un nuevo tema dentro de una unidad
mutation CreateTopic(
  $topicId: UUID!
  $code: String!
  $name: String!
  $unitId: UUID!
  $createdBy: UUID!
) @auth(level: USER) {
  topic_insert(
    data: {
      topicId: $topicId
      code: $code
      name: $name
      unitId: $unitId
      createdBy: $createdBy
      active: true
    }
  )
}

# Actualizar un tema
mutation UpdateTopic(
  $topicId: UUID!
  $unitId: UUID!
  $code: String!
  $name: String!
  $updatedBy: UUID!
  $updatedAt: Timestamp!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  topic_update(
    key: { topicId: $topicId }
    data: {
      unitId: $unitId
      code: $code
      name: $name
      updatedBy: $updatedBy
      updatedAt: $updatedAt
    }
  )
}

# Desactivar un tema (soft delete)
# Nota: Verificar si hay preguntas asociadas antes de desactivar
mutation DeactivateTopic(
  $topicId: UUID!
  $deletedAt: Timestamp!
  $deletedBy: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  topic_update(
    key: { topicId: $topicId }
    data: {
      active: false
      deletedAt: $deletedAt
      deletedBy: $deletedBy
    }
  )
}

# Reactivar un tema (undo soft delete)
mutation ReactivateTopic(
  $topicId: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  topic_update(
    key: { topicId: $topicId }
    data: {
      active: true
      deletedAt: null
      deletedBy: null
    }
  )
}

# ===================================================================
# CATEGORÍAS DE NIVELES (Level Categories)
# ===================================================================

# Crear una nueva categoría de nivel
mutation CreateLevelCategory(
  $categoryId: UUID!
  $code: String!
  $name: String!
  $description: String
  $createdBy: UUID!
) @auth(level: USER) {
  levelCategory_insert(
    data: {
      categoryId: $categoryId
      code: $code
      name: $name
      description: $description
      createdBy: $createdBy
      active: true
    }
  )
}

# Actualizar una categoría de nivel
mutation UpdateLevelCategory(
  $categoryId: UUID!
  $code: String
  $name: String
  $description: String
  $updatedBy: UUID!
  $updatedAt: Timestamp!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  levelCategory_update(
    key: { categoryId: $categoryId }
    data: {
      code: $code
      name: $name
      description: $description
      updatedBy: $updatedBy
      updatedAt: $updatedAt
    }
  )
}

# Desactivar una categoría de nivel (soft delete)
mutation DeactivateLevelCategory(
  $categoryId: UUID!
  $deletedAt: Timestamp!
  $deletedBy: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  levelCategory_update(
    key: { categoryId: $categoryId }
    data: {
      active: false
      deletedAt: $deletedAt
      deletedBy: $deletedBy
    }
  )
}

# Reactivar una categoría de nivel (undo soft delete)
mutation ReactivateLevelCategory(
  $categoryId: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  levelCategory_update(
    key: { categoryId: $categoryId }
    data: {
      active: true
      deletedAt: null
      deletedBy: null
    }
  )
}

# ===================================================================
# NIVELES EDUCACIONALES (Educational Levels)
# ===================================================================

# Crear un nuevo nivel educacional
mutation CreateEducationalLevel(
  $levelId: UUID!
  $categoryId: UUID!
  $code: String!
  $name: String!
  $description: String
  $createdBy: UUID!
) @auth(level: USER) {
  educationalLevel_insert(
    data: {
      levelId: $levelId
      categoryId: $categoryId
      code: $code
      name: $name
      description: $description
      createdBy: $createdBy
      active: true
    }
  )
}

# Actualizar un nivel educacional
mutation UpdateEducationalLevel(
  $levelId: UUID!
  $code: String
  $name: String
  $description: String
  $categoryId: UUID
  $updatedBy: UUID!
  $updatedAt: Timestamp!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  educationalLevel_update(
    key: { levelId: $levelId }
    data: {
      code: $code
      name: $name
      description: $description
      categoryId: $categoryId
      updatedBy: $updatedBy
      updatedAt: $updatedAt
    }
  )
}

# Desactivar un nivel educacional (soft delete)
mutation DeactivateEducationalLevel(
  $levelId: UUID!
  $deletedAt: Timestamp!
  $deletedBy: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  educationalLevel_update(
    key: { levelId: $levelId }
    data: {
      active: false
      deletedAt: $deletedAt
      deletedBy: $deletedBy
    }
  )
}

# Reactivar un nivel educacional (undo soft delete)
mutation ReactivateEducationalLevel(
  $levelId: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  educationalLevel_update(
    key: { levelId: $levelId }
    data: {
      active: true
      deletedAt: null
      deletedBy: null
    }
  )
}

# ===================================================================
# CURSOS (Courses)
# ===================================================================

# Crear un nuevo curso
mutation CreateCourse(
  $courseId: UUID!
  $name: String!
  $code: String!
  $section: String
  $institutionName: String!
  $levelId: UUID!
  $userId: UUID!
  $createdBy: UUID!
) @auth(level: USER) {
  course_insert(
    data: {
      courseId: $courseId
      name: $name
      code: $code
      section: $section
      institutionName: $institutionName
      levelId: $levelId
      userId: $userId
      createdBy: $createdBy
      active: true
    }
  )
}

# Actualizar un curso
mutation UpdateCourse(
  $courseId: UUID!
  $name: String!
  $code: String!
  $section: String
  $institutionName: String!
  $levelId: UUID!
  $userId: UUID!
  $updatedBy: UUID!
  $updatedAt: Timestamp!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  course_update(
    key: { courseId: $courseId }
    data: {
      name: $name
      code: $code
      section: $section
      institutionName: $institutionName
      levelId: $levelId
      userId: $userId
      updatedBy: $updatedBy
      updatedAt: $updatedAt
    }
  )
}

# Desactivar un curso (soft delete)
mutation DeactivateCourse(
  $courseId: UUID!
  $deletedAt: Timestamp!
  $deletedBy: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  course_update(
    key: { courseId: $courseId }
    data: {
      active: false
      deletedAt: $deletedAt
      deletedBy: $deletedBy
    }
  )
}

# Reactivar un curso (undo soft delete)
mutation ReactivateCourse(
  $courseId: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  course_update(
    key: { courseId: $courseId }
    data: {
      active: true
      deletedAt: null
      deletedBy: null
    }
  )
}

# ===================================================================
# PREGUNTAS (Questions)
# ===================================================================

# Crear una nueva pregunta
mutation CreateQuestion(
  $questionId: UUID!
  $text: String!
  $topicId: UUID!
  $difficultyId: UUID!
  $questionTypeId: UUID!
  $taxonomyId: UUID!
  $userId: UUID!
  $isPublic: Boolean!
  $allowPartialScore: Boolean!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  question_insert(
    data: {
      questionId: $questionId
      text: $text
      topicId: $topicId
      difficultyId: $difficultyId
      questionTypeId: $questionTypeId
      taxonomyId: $taxonomyId
      userId: $userId
      isPublic: $isPublic
      allowPartialScore: $allowPartialScore
      active: true
      version: 1
    }
  )
}

# Crear una nueva versión de una pregunta
mutation CreateQuestionVersion(
  $questionId: UUID!
  $text: String!
  $topicId: UUID!
  $difficultyId: UUID!
  $questionTypeId: UUID!
  $taxonomyId: UUID!
  $userId: UUID!
  $isPublic: Boolean!
  $allowPartialScore: Boolean!
  $version: Int!
  $originalQuestionId: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  question_insert(
    data: {
      questionId: $questionId
      text: $text
      topicId: $topicId
      difficultyId: $difficultyId
      questionTypeId: $questionTypeId
      taxonomyId: $taxonomyId
      userId: $userId
      isPublic: $isPublic
      allowPartialScore: $allowPartialScore
      active: true
      version: $version
      originalQuestionId: $originalQuestionId
    }
  )
}

# Actualizar una pregunta
mutation UpdateQuestion(
  $questionId: UUID!
  $text: String
  $topicId: UUID
  $difficultyId: UUID
  $questionTypeId: UUID
  $isPublic: Boolean
  $allowPartialScore: Boolean
  $updatedBy: UUID!
  $updatedAt: Timestamp!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  question_update(
    key: { questionId: $questionId }
    data: {
      text: $text
      topicId: $topicId
      difficultyId: $difficultyId
      questionTypeId: $questionTypeId
      isPublic: $isPublic
      allowPartialScore: $allowPartialScore
      updatedBy: $updatedBy
      updatedAt: $updatedAt
    }
  )
}

# Desactivar una pregunta (soft delete)
mutation DeactivateQuestion(
  $questionId: UUID!
  $deletedAt: Timestamp!
  $deletedBy: UUID!
  $userId: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  question_update(
    key: { questionId: $questionId }
    data: {
      active: false
      deletedAt: $deletedAt
      deletedBy: $deletedBy
    }
  )
}

# Reactivar una pregunta (undo soft delete)
mutation ReactivateQuestion(
  $questionId: UUID!
  $userId: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  question_update(
    key: { questionId: $questionId }
    data: {
      active: true
      deletedAt: null
      deletedBy: null
    }
  )
}

# Crear una opción de pregunta
mutation CreateQuestionOption(
  $questionOptionId: UUID!
  $text: String!
  $isCorrect: Boolean!
  $position: Int!
  $score: Float
  $questionId: UUID!
) @auth(level: USER) {
  questionOption_insert(
    data: {
      questionOptionId: $questionOptionId
      text: $text
      isCorrect: $isCorrect
      position: $position
      score: $score
      questionId: $questionId
    }
  )
}

# Actualizar una opción de pregunta
mutation UpdateQuestionOption(
  $questionOptionId: UUID!
  $text: String
  $isCorrect: Boolean
  $position: Int
  $score: Float
) @auth(level: USER) {
  questionOption_update(
    key: { questionOptionId: $questionOptionId }
    data: {
      text: $text
      isCorrect: $isCorrect
      position: $position
      score: $score
    }
  )
}

# Eliminar una opción de pregunta
mutation DeleteQuestionOption(
  $questionOptionId: UUID!
) @auth(level: USER) {
  questionOption_delete(
    key: { questionOptionId: $questionOptionId }
  )
}

# Crear un nuevo tipo de pregunta
mutation CreateQuestionType(
  $questionTypeId: UUID!
  $code: String!
  $name: String!
  $description: String
  $minOptions: Int!
  $maxOptions: Int!
  $correctOptions: Int!
  $active: Boolean!
) @auth(level: USER) {
  questionType_insert(
    data: {
      questionTypeId: $questionTypeId
      code: $code
      name: $name
      description: $description
      minOptions: $minOptions
      maxOptions: $maxOptions
      correctOptions: $correctOptions
      active: $active
    }
  )
}

# Actualizar un tipo de pregunta
mutation UpdateQuestionType(
  $questionTypeId: UUID!
  $code: String
  $name: String
  $description: String
  $minOptions: Int
  $maxOptions: Int
  $correctOptions: Int
) @auth(level: USER) {
  questionType_update(
    key: { questionTypeId: $questionTypeId }
    data: {
      code: $code
      name: $name
      description: $description
      minOptions: $minOptions
      maxOptions: $maxOptions
      correctOptions: $correctOptions
    }
  )
}

# Desctivar un tipo de pregunta
mutation DeactivateQuestionType(
  $questionTypeId: UUID!
) @auth(level: USER) {
  questionType_update(
    key: { questionTypeId: $questionTypeId }
    data: {
      active: false
    }
  )
}

# Reactivar un tipo de pregunta
mutation ReactivateQuestionType(
  $questionTypeId: UUID!
) @auth(level: USER) {
  questionType_update(
    key: { questionTypeId: $questionTypeId }
    data: {
      active: true
    }
  )
}

# Crear una dificultad
mutation CreateDifficulty(
  $difficultyId: UUID!
  $code: String!
  $level: String!
  $weight: Float!
  $description: String
) @auth(level: USER) {
  difficulty_insert(
    data: {
      difficultyId: $difficultyId
      code: $code
      level: $level
      weight: $weight
      description: $description
    }
  )
}

# Desctivar una dificultad
mutation DeactivateDifficulty(
  $difficultyId: UUID!
) @auth(level: USER) {
  difficulty_update(
    key: { difficultyId: $difficultyId }
    data: {
      active: false
    }
  )
}

# Reactivar una dificultad
mutation ReactivateDifficulty(
  $difficultyId: UUID!
) @auth(level: USER) {
  difficulty_update(
    key: { difficultyId: $difficultyId }
    data: {
      active: true
    }
  )
}

# ===================================================================
# TAXONOMÍAS (Taxonomies)
# ===================================================================

# Crear una nueva taxonomía
mutation CreateTaxonomy(
  $taxonomyId: UUID!
  $code: String!
  $name: String!
  $description: String
  $level: Int!
  $createdBy: UUID!
) @auth(level: USER) {
  taxonomy_insert(
    data: {
      taxonomyId: $taxonomyId
      code: $code
      name: $name
      description: $description
      level: $level
      createdBy: $createdBy
      active: true
    }
  )
}

# Actualizar una taxonomía
mutation UpdateTaxonomy(
  $taxonomyId: UUID!
  $code: String!
  $name: String!
  $description: String
  $level: Int!
  $updatedBy: UUID!
  $updatedAt: Timestamp!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  taxonomy_update(
    key: { taxonomyId: $taxonomyId }
    data: {
      code: $code
      name: $name
      description: $description
      level: $level
      updatedBy: $updatedBy
      updatedAt: $updatedAt
    }
  )
}

# Desactivar una taxonomía (soft delete)
mutation DeactivateTaxonomy(
  $taxonomyId: UUID!
  $deletedAt: Timestamp!
  $deletedBy: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  taxonomy_update(
    key: { taxonomyId: $taxonomyId }
    data: {
      active: false
      deletedAt: $deletedAt
      deletedBy: $deletedBy
    }
  )
}

# Reactivar una taxonomía (undo soft delete)
mutation ReactivateTaxonomy(
  $taxonomyId: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid || auth.token.role == 'ADMIN'") {
  taxonomy_update(
    key: { taxonomyId: $taxonomyId }
    data: {
      active: true
      deletedAt: null
      deletedBy: null
    }
  )
}

# ===================================================================
# EVALUACIONES (Evaluations)
# ===================================================================

# Crear una nueva evaluación
mutation CreateEvaluation(
  $evaluationId: UUID!
  $title: String!
  $scheduledDate: Date!
  $durationMinutes: Int!
  $gradeScale: String!
  $subjectId: UUID!
  $userId: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  evaluation_insert(
    data: {
      evaluationId: $evaluationId
      title: $title
      scheduledDate: $scheduledDate
      durationMinutes: $durationMinutes
      gradeScale: $gradeScale
      state: "DRAFT"
      subjectId: $subjectId
      userId: $userId
    }
  )
}

# Actualizar una evaluación
mutation UpdateEvaluation(
  $evaluationId: UUID!
  $title: String
  $scheduledDate: Date
  $durationMinutes: Int
  $gradeScale: String
  $subjectId: UUID
  $pdfPath: String
  $updatedBy: UUID!
  $updatedAt: Timestamp!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  evaluation_update(
    key: { evaluationId: $evaluationId }
    data: {
      title: $title
      scheduledDate: $scheduledDate
      durationMinutes: $durationMinutes
      gradeScale: $gradeScale
      subjectId: $subjectId
      pdfPath: $pdfPath
      updatedBy: $updatedBy
      updatedAt: $updatedAt
    }
  )
}

# Cambiar estado de una evaluación
# Estados: DRAFT -> PUBLISHED -> APPLIED -> GRADED -> ARCHIVED
mutation UpdateEvaluationState(
  $evaluationId: UUID!
  $state: String!
  $updatedBy: UUID!
  $updatedAt: Timestamp!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  evaluation_update(
    key: { evaluationId: $evaluationId }
    data: {
      state: $state
      updatedBy: $updatedBy
      updatedAt: $updatedAt
    }
  )
}

# Desactivar una evaluación (soft delete)
mutation DeactivateEvaluation(
  $evaluationId: UUID!
  $deletedAt: Timestamp!
  $deletedBy: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  evaluation_update(
    key: { evaluationId: $evaluationId }
    data: {
      deletedAt: $deletedAt
      deletedBy: $deletedBy
    }
  )
}

# Reactivar una evaluación (undo soft delete)
mutation ReactivateEvaluation(
  $evaluationId: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  evaluation_update(
    key: { evaluationId: $evaluationId }
    data: {
      deletedAt: null
      deletedBy: null
    }
  )
}

# ===================================================================
# PREGUNTAS DE EVALUACIÓN (Evaluation Questions)
# ===================================================================

# Asignar una pregunta a una evaluación
mutation AddQuestionToEvaluation(
  $evaluationQuestionId: UUID!
  $evaluationId: UUID!
  $questionId: UUID!
  $points: Float!
  $position: Int!
) @auth(level: USER) {
  evaluationQuestion_insert(
    data: {
      evaluationQuestionId: $evaluationQuestionId
      evaluationId: $evaluationId
      questionId: $questionId
      points: $points
      position: $position
    }
  )
}

# Actualizar puntos o posición de una pregunta en evaluación
mutation UpdateEvaluationQuestion(
  $evaluationQuestionId: UUID!
  $points: Float
  $position: Int
) @auth(level: USER) {
  evaluationQuestion_update(
    key: { evaluationQuestionId: $evaluationQuestionId }
    data: {
      points: $points
      position: $position
    }
  )
}

# Remover una pregunta de una evaluación
mutation RemoveQuestionFromEvaluation(
  $evaluationQuestionId: UUID!
) @auth(level: USER) {
  evaluationQuestion_delete(
    key: { evaluationQuestionId: $evaluationQuestionId }
  )
}

# ===================================================================
# ASIGNACIÓN DE EVALUACIONES A CURSOS (Course Evaluations)
# ===================================================================

# Asignar una evaluación a un curso
mutation AssignEvaluationToCourse(
  $courseEvaluationId: UUID!
  $courseId: UUID!
  $evaluationId: UUID!
  $createdBy: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  courseEvaluation_insert(
    data: {
      courseEvaluationId: $courseEvaluationId
      courseId: $courseId
      evaluationId: $evaluationId
      createdBy: $createdBy
    }
  )
}

# Remover asignación de evaluación de un curso
mutation RemoveEvaluationFromCourse(
  $courseEvaluationId: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  courseEvaluation_delete(
    key: { courseEvaluationId: $courseEvaluationId }
  )
}

# ===================================================================
# ESTUDIANTES (Students)
# ===================================================================

# Crear un nuevo estudiante
mutation CreateStudent(
  $studentId: UUID!
  $firstName: String!
  $lastName: String!
  $identifier: String!
  $createdBy: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  student_insert(
    data: {
      studentId: $studentId
      firstName: $firstName
      lastName: $lastName
      identifier: $identifier
      createdBy: $createdBy
    }
  )
}

# Actualizar un estudiante
mutation UpdateStudent(
  $studentId: UUID!
  $firstName: String
  $lastName: String
  $identifier: String
  $updatedBy: UUID!
  $updatedAt: Timestamp!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  student_update(
    key: { studentId: $studentId }
    data: {
      firstName: $firstName
      lastName: $lastName
      identifier: $identifier
      updatedBy: $updatedBy
      updatedAt: $updatedAt
    }
  )
}

# Desactivar un estudiante (soft delete)
mutation DeactivateStudent(
  $studentId: UUID!
  $deletedAt: Timestamp!
  $deletedBy: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  student_update(
    key: { studentId: $studentId }
    data: {
      deletedAt: $deletedAt
      deletedBy: $deletedBy
    }
  )
}

# Reactivar un estudiante (undo soft delete)
mutation ReactivateStudent(
  $studentId: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  student_update(
    key: { studentId: $studentId }
    data: {
      deletedAt: null
      deletedBy: null
    }
  )
}

# ===================================================================
# INSCRIPCIÓN DE ESTUDIANTES EN CURSOS (Course Students)
# ===================================================================

# Inscribir un estudiante en un curso
mutation EnrollStudentInCourse(
  $courseStudentId: UUID!
  $courseId: UUID!
  $studentId: UUID!
  $enrolledOn: Date!
  $createdBy: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  courseStudent_insert(
    data: {
      courseStudentId: $courseStudentId
      courseId: $courseId
      studentId: $studentId
      enrolledOn: $enrolledOn
      createdBy: $createdBy
    }
  )
}

# Actualizar inscripción de estudiante
mutation UpdateCourseStudent(
  $courseStudentId: UUID!
  $enrolledOn: Date
  $updatedBy: UUID!
  $updatedAt: Timestamp!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  courseStudent_update(
    key: { courseStudentId: $courseStudentId }
    data: {
      enrolledOn: $enrolledOn
      updatedBy: $updatedBy
      updatedAt: $updatedAt
    }
  )
}

# Desmatricular estudiante de un curso (soft delete)
mutation UnenrollStudentFromCourse(
  $courseStudentId: UUID!
  $deletedAt: Timestamp!
  $deletedBy: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  courseStudent_update(
    key: { courseStudentId: $courseStudentId }
    data: {
      deletedAt: $deletedAt
      deletedBy: $deletedBy
    }
  )
}

# Re-matricular estudiante en un curso (undo soft delete)
mutation ReenrollStudentInCourse(
  $courseStudentId: UUID!
  $firebaseId: String!
) @auth(expr: "firebaseId == auth.uid") {
  courseStudent_update(
    key: { courseStudentId: $courseStudentId }
    data: {
      deletedAt: null
      deletedBy: null
    }
  )
}

# ===================================================================
# EVALUACIONES DE ESTUDIANTES (Student Course Evaluations)
# ===================================================================

# Crear/Asignar una evaluación a un estudiante (crear la "copia" de la evaluación)
mutation CreateStudentEvaluation(
  $studentCourseEvaluationId: UUID!
  $courseEvaluationId: UUID!
  $courseStudentId: UUID!
) @auth(level: USER) {
  studentCourseEvaluation_insert(
    data: {
      studentCourseEvaluationId: $studentCourseEvaluationId
      courseEvaluationId: $courseEvaluationId
      courseStudentId: $courseStudentId
      totalScore: 0
      state: "CREATED"
    }
  )
}

# Cambiar estado de evaluación de estudiante
# Estados: CREATED -> ASSIGNED -> IN_PROGRESS -> COMPLETED -> GRADED
mutation UpdateStudentEvaluationState(
  $studentCourseEvaluationId: UUID!
  $state: String!
) @auth(level: USER) {
  studentCourseEvaluation_update(
    key: { studentCourseEvaluationId: $studentCourseEvaluationId }
    data: {
      state: $state
    }
  )
}

# Iniciar evaluación del estudiante (marcar fecha de inicio)
mutation StartStudentEvaluation(
  $studentCourseEvaluationId: UUID!
  $takenOn: Timestamp!
  $attemptNo: Int!
) @auth(level: USER) {
  studentCourseEvaluation_update(
    key: { studentCourseEvaluationId: $studentCourseEvaluationId }
    data: {
      takenOn: $takenOn
      attemptNo: $attemptNo
      state: "IN_PROGRESS"
    }
  )
}

# Finalizar evaluación del estudiante
mutation CompleteStudentEvaluation(
  $studentCourseEvaluationId: UUID!
) @auth(level: USER) {
  studentCourseEvaluation_update(
    key: { studentCourseEvaluationId: $studentCourseEvaluationId }
    data: {
      state: "COMPLETED"
    }
  )
}

# Calificar evaluación del estudiante (registrar puntaje y nota)
mutation GradeStudentEvaluation(
  $studentCourseEvaluationId: UUID!
  $totalScore: Float!
  $grade: Float!
) @auth(level: USER) {
  studentCourseEvaluation_update(
    key: { studentCourseEvaluationId: $studentCourseEvaluationId }
    data: {
      totalScore: $totalScore
      grade: $grade
      state: "GRADED"
    }
  )
}

# Actualizar puntaje total de evaluación del estudiante
mutation UpdateStudentEvaluationScore(
  $studentCourseEvaluationId: UUID!
  $totalScore: Float!
) @auth(level: USER) {
  studentCourseEvaluation_update(
    key: { studentCourseEvaluationId: $studentCourseEvaluationId }
    data: {
      totalScore: $totalScore
    }
  )
}

# ===================================================================
# PREGUNTAS DE EVALUACIÓN DEL ESTUDIANTE (Student Evaluation Questions)
# ===================================================================

# Asignar una pregunta específica a la evaluación del estudiante
mutation AddQuestionToStudentEvaluation(
  $studentEvaluationQuestionId: UUID!
  $studentEvaluationId: UUID!
  $evaluationQuestionId: UUID!
  $position: Int!
) @auth(level: USER) {
  studentEvaluationQuestion_insert(
    data: {
      studentEvaluationQuestionId: $studentEvaluationQuestionId
      studentEvaluationId: $studentEvaluationId
      evaluationQuestionId: $evaluationQuestionId
      position: $position
    }
  )
}

# Registrar resultado de una pregunta del estudiante (después de calificar)
mutation GradeStudentQuestion(
  $studentEvaluationQuestionId: UUID!
  $scoreObtained: Float!
  $isCorrect: Boolean!
) @auth(level: USER) {
  studentEvaluationQuestion_update(
    key: { studentEvaluationQuestionId: $studentEvaluationQuestionId }
    data: {
      scoreObtained: $scoreObtained
      isCorrect: $isCorrect
    }
  )
}

# Actualizar posición de pregunta en evaluación del estudiante
mutation UpdateStudentQuestionPosition(
  $studentEvaluationQuestionId: UUID!
  $position: Int!
) @auth(level: USER) {
  studentEvaluationQuestion_update(
    key: { studentEvaluationQuestionId: $studentEvaluationQuestionId }
    data: {
      position: $position
    }
  )
}

# Eliminar pregunta de evaluación del estudiante
mutation RemoveQuestionFromStudentEvaluation(
  $studentEvaluationQuestionId: UUID!
) @auth(level: USER) {
  studentEvaluationQuestion_delete(
    key: { studentEvaluationQuestionId: $studentEvaluationQuestionId }
  )
}

# ===================================================================
# RESPUESTAS DEL ESTUDIANTE (Student Answer Options)
# ===================================================================

# Registrar una respuesta del estudiante (selección de opción)
mutation RegisterStudentAnswer(
  $studentAnswerOptionId: UUID!
  $studentEvaluationQuestionId: UUID!
  $questionOptionId: UUID!
) @auth(level: USER) {
  studentAnswerOption_insert(
    data: {
      studentAnswerOptionId: $studentAnswerOptionId
      studentEvaluationQuestionId: $studentEvaluationQuestionId
      questionOptionId: $questionOptionId
    }
  )
}

# Eliminar una respuesta del estudiante (des-seleccionar opción)
mutation RemoveStudentAnswer(
  $studentAnswerOptionId: UUID!
) @auth(level: USER) {
  studentAnswerOption_delete(
    key: { studentAnswerOptionId: $studentAnswerOptionId }
  )
}

# Eliminar todas las respuestas de una pregunta (para re-responder)
# Nota: Esta operación debe hacerse desde la aplicación iterando sobre las respuestas
# ya que Data Connect no soporta delete masivo con where

# ===================================================================
# OPERACIONES EN LOTE - Helpers para la aplicación
# ===================================================================

# Nota: Las siguientes operaciones en lote deben manejarse desde la aplicación
# llamando múltiples mutaciones en secuencia:
#
# 1. AssignEvaluationToAllStudentsInCourse:
#    - Obtener todos los CourseStudent del curso
#    - Para cada uno, crear StudentCourseEvaluation
#    - Para cada StudentCourseEvaluation, crear StudentEvaluationQuestion por cada pregunta
#
# 2. CopyEvaluationQuestionsToStudent:
#    - Obtener todas las EvaluationQuestion de la evaluación
#    - Para cada una, crear StudentEvaluationQuestion
#
# 3. GradeAllStudentAnswers:
#    - Obtener todas las StudentEvaluationQuestion
#    - Para cada una, comparar respuestas con opciones correctas
#    - Actualizar scoreObtained e isCorrect
#    - Calcular totalScore y grade

# ===================================================================
# FIN DE ARCHIVO
# ===================================================================